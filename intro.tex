\section{Introduction}\label{sec:intro}

\emph{Structure editors}
have long promised to improve the programming experience
for beginners and experts alike.
By eliminating parse errors,
they provide cognitive benefits for novices
  \cite{meta-analysis-blocks,blocks-text-high-school,coblox}
  and end-users
  \cite{weitnauer2016graspable,rousillon,BasHermans21};
  simplify language composition
  \cite{mbeddr}
  and language-aware editor tooling
  \cite{HazelnutSNAPL};
  and form an essential component of truly continuous live programming
  \cite{Hazelnut,HazelnutLive}.
Yet, in the forty years since the idea was first
introduced and implemented \cite{Cornell},
structure editing has failed to reach
mainstream use by programmers beyond the novice level.
The problem, as many have observed
\cite{user-modeling,fine-tuning-selection-semantics,
practical-lang-based-editing,lang-on-the-usefulness,
psg,Minor92,TowardUserFriendly,MillerPMV94},
is that structure editors have consistently suffered
from prohibitive usability issues.

For example, while
block-based editors like Scratch \cite{scratch}
have seen great success in introducing programming
to children and end-users, they soon become unwieldy
as users gain experience and create larger programs.
Cited issues include their inefficient mouse-driven
input, low visual information density, and rigid
tree-based construction of operator sequences
\cite{BlocksFingertips,cog-dim-blocks,blocks-and-beyond}.

Other structure editors like JetBrains MPS \note{cite}
resolve those particular issues with
keyboard-driven text-like interfaces, but instead suffer
from steep learning curves and difficult-to-predict
editing behavior.
Consider the violin plots in Figure \ref{fig:mps-violin-plots},
which show post-task questionnaire responses from
a controlled user study of MPS \cite{ProjEfficiency}.
The left two plots shows that MPS novices felt that
selection was relatively slow and inaccurate despite
a 45-minute training session and another 30-45 minutes
worth of study tasks.
Meanwhile, the right two plots show that
MPS novices and \emph{experts} alike struggled to
predict the effects of deletion.

\begin{figure}[b]
  \centering
  \includegraphics[width=\columnwidth]{img/mps-violin-plots.png}
  \caption{Violin plots of post-task questionnaire responses
  from a controlled user study of MPS, curated from \cite{ProjEfficiency}
  and annotated with labels.
  Each plot partitions the responses across the three study groups:
  novice MPS users (Proj), expert MPS users (ProjE),
  and text editor users (Par).
  }
  \label{fig:mps-violin-plots}
\end{figure}

Whether they are mouse-driven and block-based,
or keyboard-driven and text-like,
structure editors as a whole have suffered
from high viscosity \cite{cog-dim},
\ie, it is difficult to modify
and restructure existing code.
We believe this is a fundamental consequence
of the heretofore core assumption that structure editors
should operate directly on the abstract syntactic structure
of a program.
This assumption restricts selections to complete
program terms, a severe limitation compared to
the arbitrary range selections of text editors.

In this paper, we present a new approach to structure
editing, called \emph{tile-based editing}, that
recovers many of the flexible and linear editing
affordances of text editors.
Instead of representing the program in the language's
abstract syntax, a tile-based editor represents it
in a parallel tile-based syntax equipped with its own
syntax-directed editing.
Closely related to nested words \cite{nested-words}
and visibly pushdown languages \cite{visibly-pushdown-langs},
tiles encode both the linearity of sequentially
positioned syntactic elements as well as
their hierarchical nesting between matching sets
of delimiters.

\note{modal editing, disassembly into shards,
supporting arbitrary range selections up to token boundaries}

\note{contributions: design and implementation of a
minimal tile-based editor,
formalization sketch of tile-based editing,
discussion of how tile-based editing can be scaled up
to more text-like interfaces like Hazel, plan to evaluate}

