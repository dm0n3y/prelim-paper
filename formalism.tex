% !TEX root = prelim-paper.tex

\section{Tile-based Editor Calculus}\label{sec:formalism}

We now precisely specify tile-based editing
as a calculus called \ty.
The punchline of \ty~ (Section \ref{sec:actions})
is the action judgment
$\performAction{\editState_1}{\action}{\editState_2}$,
which sends edit state $\editState_1$ to $\editState_2$
via action $\action$, and its governing metatheory,
which states that every action-reachable edit state
can be parsed into a well-formed program term.
\note{call back to figure in section 2}

Parsing in \ty~ is stratified into two phases:
assembling shards into tiles, and precedence-parsing
tiles into terms.
We will begin in Section \ref{sec:terms-tiles-tips}
by showing that the precedence-parsing phase is
guaranteed to succeed provided the input tiles form
an opseq.
As a result, we can structure \ty~ edit states using
tiles rather than terms (Section \ref{sec:edit-states}),
and the actions operating on edit states need only
concern themselves with shard assembly and fixing holes
to maintain opseq structure (Section \ref{sec:actions}).

% \note{something about how both of these parsing steps
% deviate from the usual approach of parsing, which takes
% a sequence of characters or tokens and produces a
% parse tree, whereas here we have more fine-grained
% delineation between different parseable/parsed structures,
% which is why we take care in this section to define
% derivations from one structure to another}

\note{add some high level preview about edit states, zippers,
justify this organization so that people are happy to wait;
consider giving an example right away as I discuss bottom-up zippers}

% \note{without more preview into edit states, can be misleading
% into thinking edit states are just all tiles rather than
% having a focused subject}

% \note{edit states are bottom-up zippers, actions act at subject, etc,
% note that need not re-parse entire program}


\subsection{Terms, tiles, \& tips} \label{sec:terms-tiles-tips}

The syntax for terms and tiles were presented in
Figure \ref{fig:term-tile-syntax}.
\note{talk about we define precedence-parsing from tiles
to terms via ``derivations'' much like we define parsing
on character sequences according to a CFG}

\input{term-flattening}
\input{tip-syntax}
% \input{fix-holes-judgment}
\input{hole-fixing-judgment}

\begin{definition}
  A selection $\selection$ is an \emph{opseq of sort $s$} if
  it is intact and $\lltip{s}~\rrtip{s}$-connected.
\end{definition}

\begin{theorem}
  A selection $\selection$ is an opseq of sort $s$
  if and only if there exists a term $x$ of sort $s$ such that
  $\flattenTerm{x}{\selection}$.
  \note{todo: sort-indexed term notation, need to address children well-formedness}
\end{theorem}

Finally we establish the connection between
\ty~ edit states and \emph{terms} of the
underlying language, as are typically defined
with a strictly tree-structured abstract syntax.
Figure \note{ref} shows the abstract syntax of
\ty~ language terms;
this syntax coincides with that in Figure \note{ref}
except for the inclusion of a new operator hole term
to account for operator holes in the tile syntax.

Figure \note{ref} defines the judgments
$\flattenTerm{p}{\tiles^{\pat}}$
and
$\flattenTerm{e}{\tiles^{\expr}}$,
which specify how to ``flatten'' a tree-structured
term into a corresponding sequence of tiles.
We consider a tile sequence $\tiles^s$ to be well-formed
with respect to the underlying language if there exists
a language term that flattens to $\tiles^s$.
\note{talk a bit about the parentheses rule, note that this is just for stating theorem}

Showing the existence of such a language term
is equivalent to showing the tiles in $\tiles^s$
form a valid operator sequence.
Each tile may be interpreted as a component
of an operator sequence, taking one of four
different shapes: operand, unary prefix,
unary suffix, and binary infix...



\subsection{Edit states} \label{sec:edit-states}
\input{edit-state-syntax}

\note{set up running example right away}

We start with an overview of the syntax of \ty~ edit states,
presented altogether in Figure \ref{fig:edit-state-syntax}.
Edit states in \ty~ are sort-indexed structures
$\zipper{\subject}{\tfrelem^s}$ that follow a variant
of the zipper pattern first described by Huet.
In particular, they have a \emph{bottom-up}
zipper structure \note{cite}---consisting of a focused substructure
$\subject$ and, separately,
its surrounding ``inside-out'' context $\tfrelem^s$---unlike
the top-down structure adopted in other work \note{cite}.
In this work, we call the focused substructure the \emph{subject} of
the zipper and its surrounding context the \emph{frame}.

\subsubsection{Tiles, tokens, \& selections}
The subject $\sigma$ of a zipper $\zipper{\subject}{\tfrelem^s}$
may be in one of three modes.
\note{name them here}
We defer higher-level discussion regarding their roles in
editing to Section \note{ref}, where we define \ty's editing
operations, and focus now on the structures that constitute them.

% The first mode, called \emph{pointing mode}, consists of
% a pair of tiles of the sort expected by the frame.
% We described the syntax of tiles
% in Section \ref{sec:overview};
% the same syntax that was presented in Figure \note{ref}
% is presented again in Figure \note{ref} in context.

% The second and third modes, called \emph{selecting mode}
% and \emph{restructuring mode}, each consist of a trio of
% \emph{selections}.

\note{add back some discussion of tiles/tokens here}

All three modes consist of two or more \emph{selections}.
A selection is a linear sequence of heterogeneously
sorted \emph{tiles} and \emph{tokens}.
We described the syntax of tiles $\tile^s$
in Section \ref{sec:overview};
the same syntax that was presented in Figure \ref{fig:tile-syntax}
is presented again in Figure \ref{fig:edit-state-syntax} in context.
Tokens $\token^s$ are the lexical components of tiles, forming either
the substance of childless tiles or the delimiters of parent
tiles' children.
Tokens are generated from tiles via the \emph{tile disassembly} function
$\disassembleTile{\cdot}$, defined in Figure \ref{fig:disassemble-tile},
which takes a tile and produces
a selection consisting of the tile's tokens
and the tile's children tiles.
\note{need more examples}

\note{find different phrasing here that doesn't invite interpretation as technical terms}
Selections have a permissive syntax, with multiple
ways of representing the same essential content.
For example, both a singleton tile and the tile's disassembly
form valid selections.
\note{make this a real example}
Such a permissive syntax is useful for representing
arbitrary divisions of a program's
lexical components, but we would like to ensure
that the divided selections remain ``maximally assembled''
in order to inform the user of the top-level structures
they are manipulating.
\note{give explicit examples of divisions showing maximally
and non-maximally assembled selections}

This calls for defining an appropriate
parser on selections to maintain
maximal structure as they grow and shrink during editing.
\note{make this more precise "when the selection changes",
perhaps add another example here of a selection growing}
Such a parser cannot be specified in the standard way
with a context-free grammar because such parsers are
all-or-nothing, whereas in our case our parser should
produce structure opportunistically while not requiring any
specific top-level form.
\note{maybe don't talk about this here, if anything talk about
it after I define what we did}
Much as a CFG-based parser identifies a derivation from
the CFG's start symbol to the input string,
our selection parser identifies an analogous ``disassembly'' from
a maximally structured selection to the input selection.
\note{more example}
Figure \ref{fig:disassemble-selection} defines the step-disassembly relation $\selection_1\searrow\selection_2$,
which chooses a tile in $\selection_1$ and replaces it with the
result of its disassembly.
We can show that the reflexive transitive
closure $\searrow^*$ of $\searrow$, called \emph{selection disassembly},
is a partial order in
which every selection has a unique maximal element that
disassembles to it.
\begin{lemma}
  $\searrow^*$ is a partial order.
\end{lemma}
\begin{lemma}\label{lemma:unique-parsed-selection}
  For every selection $\selection$, there is a unique
  selection $\selection'$ such that:
  \begin{itemize}
  \item $\selection'\searrow^*\selection$, and
  \item $\selection'$ is maximal: if $\selection''\searrow^*\selection'$ then $\selection'' = \selection'$.
  \end{itemize}
\end{lemma}
Lemma \ref{lemma:unique-parsed-selection} makes it
possible to specify a well-defined \emph{selection assembly}
function:
\begin{definition}
  Given a selection $\selection$, let $\parseSelection{\selection}$ be
  the unique maximal selection that disassembles down
  to $\selection$.
\end{definition}
We defer presenting a constructive implementation of this function
to the imaginary appendix.

\input{disassemble-tile}
\input{disassemble-selection}

\subsubsection{Frames \& zippers}
The sort-indexed frame $\tfrelem^s$ of a zipper
$\zipper{\subject}{\tfrelem^s}$ models the rest of
the program surrounding the subject $\subject$,
the sort index $s$ specifying what sort is expected
of the subject.
Frames are nested in bottom-up fashion, starting
with the nearest containing structure and concluding
with the program root.
For example, if the edit subject is located at $\Box$
in the program \texttt{let x = ( $\Box$ ) + 1 in x + 2},
then the frame is represeted in our syntax as
\[
  \tframelit{
    \sparen{\_}
  }{
    \tframelit{
      \_\splus{}{\texttt{1}}
    }{
      \tframelit{
        \slet{\texttt{x}}{\_}{}
      }{
        \tframelit{
          \_\ \splus{\texttt{x}}{\texttt{2}}
        }{
          \note{root}
        }
      }
    }
  }
\]
Notice that frames alternate between \emph{tile
frames} $\tfrelem^s$ that form bidelimited containers and
\emph{sequence frames} $\tframe^s$ consisting of the tiles
surrounding each tile frame.

% Having defined subjects and frames, we may now
% define the syntax of edit states,
% shown in Figure \note{ref}.
% An edit state consists of a sort-indexed \emph{zipper},
% each consisting of a subject and a frame of the
% specified sort.

% \input{frame-syntax}
% \input{zipper-syntax}
\input{disassemble-frame-tile}
\input{step-disassemble-zipper}

Like tiles, frames may be decomposed into their
lexically constituent tiles and tokens via the
\emph{frame disassembly} function $\disassembleTileFrame{\cdot}$,
defined in Figure \note{ref}.
Similar to how we lift tile disassembly to selection
disassembly, we can lift frame disassembly to
\emph{edit state step-disassembly}, defined in Figure \note{ref}.
We can show that the reflexive transitive closure
$\nearrow^*$ of $\nearrow$, which we call \emph{edit state disassembly},
is a partial order in
which every edit state with a subject in pointing mode
has a unique minimal element that disassembles up to it:
\begin{lemma}
  $\nearrow^*$ is a partial order.
\end{lemma}
\begin{lemma}\label{lemma:unique-parsed-editstate}
  For every edit state $\editState = \zipper{\pointing{\selection_1}{\selection_2}}{\tfrelem^s}$,
  there exists a unique $\editState' = \zipper{\pointing{\selection'_1}{\selection'_2}}{\tfrelem^{s'}}$ such that
  \begin{itemize}
  \item $\editState' \nearrow^* \editState$, and
  \item if $\editState'' \nearrow^* \editState'$ then $\editState'' = \editState'$.
  \end{itemize}
\end{lemma}
Lemma \ref{lemma:unique-parsed-editstate} makes it
possible to specify a well-defined parsing function
on edit states in pointing mode:
\begin{definition}
  Given an edit state $\editState = \zipper{\pointing{\selection_1}{\selection_2}}{\tfrelem^s}$,
  let $\parseZipper{\editState}$ be the unique minimal edit state
  that disassembles up to $\editState$.
\end{definition}

% \begin{definition}
%   $\zeta^s_1\nearrow\zeta^s_2$ if $\disassembleTileFrame{\zeta^s_1} = \zeta^s_2$.
%   \note{defined this for symmetry with diassembling of tiles}
% \end{definition}

% \begin{definition}
%   $\nearrow^*$ is the reflexive transitive closure of $\nearrow$.
% \end{definition}

\subsection{Actions} \label{sec:actions}

\note{add invariants for all modes, or consider
modifying restructuring movement to take into account
sort (but emphasize what is obligatory as you scale)}

We now present \ty's central action judgment
$\performAction{\editState_1}{\action}{\editState_2}$,
which sends edit state $\editState_1$ to $\editState_2$
via action $\action$.
The action judgment is governed by a syntactic sensibility
theorem (Theorem \note{ref}) that ensures that
the subject of every action-reachable edit state can
be parsed into language term.

\input{filter-tiles}
\input{whole-selection}
\input{action-syntax}

\input{move-pointing}
\input{move-selecting}
\input{move-restructuring}
\input{action-judgment}

\note{
  Define actions more generally than \tylr~ implementation,
  such that delimiters are assigned sorts to their ends,
  selections are not restricted to shards and
  same-sort tiles, and only selections whose ends are the
  same may enter restructuring mode.
}

% (2 * [3])  ->  (2 * (3 + [_]))

\begin{itemize}
  \item explain action judgment + choice rules
  \item theorems
  \begin{itemize}
    \item movability
    \item selectability
    \item restructuring is sound and complete
  \end{itemize}
\end{itemize}

\begin{theorem}
  Suppose $Z = \zipper{\subject}{\tfrelem^s}$ is a reachable edit state.
  \begin{enumerate}
  \item[(1)] If $\subject = \pointing{\selection_1}{\selection_2}$,
    then $\selection_1\selection_2$ is an opseq of sort $s$.
  \item[(2)] If $\subject = \selecting{\selection_1}{\selection_2}{\selection_3}$,
    then $\parseSelection{\selection_1\selection_2\selection_3}$ is an opseq of sort $s$.
  \item[(3)] If $\subject = \restructuring{\selection_1}{\selection_2}{\selection_3}$...
    \begin{enumerate}
      \item[(a)] ...and $\selection_2$ is intact, then
        $\selection_1\selection_3$ is an opseq of sort $s$.
      \item[(b)] ...and $\selection_2$ is cracked, then
        $\parseSelection{\selection_1\selection_2\selection_3}$ is an opseq of sort $s$.
    \end{enumerate}
  \end{enumerate}
\end{theorem}

\begin{theorem}

\end{theorem}

% \subsection{Typechecking}
% \note{
%   Define tree-structured variants of tiles and frames.
%   Define precedence parser that converts linear forms to tree forms
%   (or assume existence of such parser?).
%   Define type
% }
