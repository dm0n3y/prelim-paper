% !TEX root = prelim-paper.tex

\section{Tile-based Editor Calculus}\label{sec:formalism}

We now present a precise specification of tile-based
editing in the form of a core calculus called \ty.

% The punchline of \ty~ is the action judgment
% $\performAction{\editState_1}{\action}{\editState_2}$ \note{section ref},
% which sends edit state $\editState_1$ to $\editState_2$
% via action $\alpha$.
% These actions are governed by a syntactic sensibility theorem \note{ref},
% which states that every action-reachable edit state can
% be parsed into a language term.
% Section \note{ref} presents the action judgment and characterizes
% its metatheory.

\subsection{Edit states}
\input{edit-state-syntax}

We start with an overview of the syntax of \ty~ edit states,
presented altogether in Figure \ref{fig:edit-state-syntax}.
Edit states in \ty~ are sort-indexed structures
$\zipper{\subject}{\tfrelem^s}$ that follow a variant
of the zipper pattern first described by Huet.
In particular, they have a \emph{bottom-up}
zipper structure \note{cite}---consisting of a focused substructure
$\subject$ and, separately,
its surrounding ``inside-out'' context $\tfrelem^s$---unlike
the top-down structure adopted in other work \note{cite}.
In this work, we call the focused substructure the \emph{subject} of
the zipper and its surrounding context the \emph{frame}.

\subsubsection{Tiles, tokens, \& selections}
The subject $\sigma$ of a zipper $\zipper{\subject}{\tfrelem^s}$
may be in one of three modes.
We defer higher-level discussion regarding their roles in
editing to Section \note{ref}, where we define \ty's editing
operations, and focus now on the structures that constitute them.

% The first mode, called \emph{pointing mode}, consists of
% a pair of tiles of the sort expected by the frame.
% We described the syntax of tiles
% in Section \ref{sec:overview};
% the same syntax that was presented in Figure \note{ref}
% is presented again in Figure \note{ref} in context.

% The second and third modes, called \emph{selecting mode}
% and \emph{restructuring mode}, each consist of a trio of
% \emph{selections}.
All three modes consist of two or more \emph{selections}.
A selection is a linear sequence of heterogeneously
sorted \emph{tiles} and \emph{tokens}.
We described the syntax of tiles $\tile^s$
in Section \ref{sec:overview};
the same syntax that was presented in Figure \ref{fig:tile-syntax}
is presented again in Figure \ref{fig:edit-state-syntax} in context.
Tokens $\token^s$ are the lexical components of tiles, forming either
the substance of childless tiles or the delimiters of parent
tiles' children.
Tokens are generated from tiles via the \emph{tile disassembly} function
$\disassembleTile{\cdot}$, defined in Figure \ref{fig:disassemble-tile},
which takes a tile and produces
a selection consisting of the tile's tokens
and the tile's children tiles.

Selections have a permissive syntax, with multiple
ways of representing the same essential content.
For example, both a singleton tile and the tile's disassembly
form valid selections.
Such a permissive syntax is useful for representing
arbitrary divisions and rearrangements of a program's
lexical components, but we would like to ensure
that selections remain ``maximally assembled''
in order to inform the user of the top-level structures
they are manipulating.
This calls for defining an appropriate
parser on selections to maintain
maximal structure as they grow and shrink during editing.

Such a parser cannot be specified in the standard way
with a context-free grammar because such parsers are
all-or-nothing, whereas in our case our parser should
produce structure opportunistically while not requiring any
specific top-level form.
Much as a CFG-based parser identifies a derivation from
the CFG's start symbol to the input string,
our selection parser identifies an analogous ``disassembly'' from
a maximally structured selection to the input selection.
Figure \ref{fig:disassemble-selection} defines the step-disassembly relation $\selection_1\searrow\selection_2$,
which chooses a tile in $\selection_1$ and replaces it with the
result of its disassembly.
We can show that the reflexive transitive
closure $\searrow^*$ of $\searrow$, called \emph{selection disassembly},
is a partial order in
which every selection has a unique maximal element that
disassembles to it.
\begin{lemma}
  $\searrow^*$ is a partial order.
\end{lemma}
\begin{lemma}\label{lemma:unique-parsed-selection}
  For every selection $\Psi$, there is a unique
  element $\Psi'$ such that:
  \begin{itemize}
  \item $\Psi'\searrow^*\Psi$, and
  \item if $\Psi''\searrow^*\Psi'$ then $\Psi'' = \Psi'$.
  \end{itemize}
\end{lemma}
Lemma \ref{lemma:unique-parsed-selection} makes it
possible to specify a well-defined \emph{selection assembly}
function:
\begin{definition}
  Given a selection $\selection$, let $\parseSelection{\selection}$ be
  the unique maximal selection that disassembles
  to $\selection$.
\end{definition}
We defer presenting a constructive implementation of this function
to the imaginary appendix.

\input{disassemble-tile}
\input{disassemble-selection}

\subsubsection{Frames \& zippers}
The sort-indexed frame $\tfrelem^s$ of a zipper
$\zipper{\subject}{\tfrelem^s}$ models the rest of
the program surrounding the subject $\subject$,
the sort index specifying what sort is expected
of the subject.
Frames are nested in bottom-up fashion, starting
with the nearest containing structure and concluding
with the program root.
For example, if the edit subject is located at $\Box$
in the program \texttt{let x = ( $\Box$ ) + 1 in x + 2},
then the frame is modeled by our syntax as
\[
  \tframelit{
    \sparen{\_}
  }{
    \tframelit{
      \_\splus{}{\texttt{1}}
    }{
      \tframelit{
        \slet{\texttt{x}}{\_}{}
      }{
        \tframelit{
          \_\ \splus{\texttt{x}}{\texttt{2}}
        }{
          \note{root}
        }
      }
    }
  }
\]
Notice that frames alternate between \emph{tile
frames} $\tfrelem^s$ that form bidelimited containers and
\emph{sequence frames} $\tframe^s$ consisting of the tiles
surrounding each tile frame.

% Having defined subjects and frames, we may now
% define the syntax of edit states,
% shown in Figure \note{ref}.
% An edit state consists of a sort-indexed \emph{zipper},
% each consisting of a subject and a frame of the
% specified sort.

% \input{frame-syntax}
% \input{zipper-syntax}
\input{disassemble-frame-tile}
\input{step-disassemble-zipper}

Like tiles, frames may be decomposed into their
lexically constituent tiles and tokens via the
\emph{frame disassembly} function $\disassembleTileFrame{\cdot}$,
defined in Figure \note{ref}.
Similar to how we lift tile disassembly to selection
disassembly, we can lift frame disassembly to
\emph{edit state step-disassembly}, defined in Figure \note{ref}.
We can show that the reflexive transitive closure
$\nearrow^*$ of $\nearrow$, which we call \emph{edit state disassembly},
is a partial order in
which every edit state with a subject in pointing mode
has a unique minimal element that disassembles to it:
\begin{lemma}
  $\nearrow^*$ is a partial order.
\end{lemma}
\begin{lemma}\label{lemma:unique-parsed-editstate}
  For every edit state $\editState = \zipper{\pointing{\selection_1}{\selection_2}}{\tfrelem^s}$,
  there exists a unique $\editState' = \zipper{\pointing{\selection'_1}{\selection'_2}}{\tfrelem^{s'}}$ such that
  \begin{itemize}
  \item $\editState' \nearrow^* \editState$, and
  \item if $\editState'' \nearrow^* \editState'$ then $\editState'' = \editState'$.
  \end{itemize}
\end{lemma}
Lemma \ref{lemma:unique-parsed-editstate} makes it
possible to specify a well-defined parsing function
on edit states in pointing mode:
\begin{definition}
  Given an edit state $\editState = \zipper{\pointing{\selection_1}{\selection_2}}{\tfrelem^s}$,
  let $\parseZipper{\editState}$ be the unique minimal edit state
  that disassembles to $\editState$.
\end{definition}

% \begin{definition}
%   $\zeta^s_1\nearrow\zeta^s_2$ if $\disassembleTileFrame{\zeta^s_1} = \zeta^s_2$.
%   \note{defined this for symmetry with diassembling of tiles}
% \end{definition}

% \begin{definition}
%   $\nearrow^*$ is the reflexive transitive closure of $\nearrow$.
% \end{definition}

\subsubsection{Terms, tips, \& hole fixing}
\input{term-flattening}
\input{tip-syntax}
% \input{fix-holes-judgment}
\input{hole-fixing-judgment}

Finally we establish the connection between
\ty~ edit states and \emph{terms} of the
underlying language, as are typically defined
with a strictly tree-structured abstract syntax.
Figure \note{ref} shows the abstract syntax of
\ty~ language terms;
this syntax coincides with that in Figure \note{ref}
except for the inclusion of a new operator hole term
to account for operator holes in the tile syntax.

Figure \note{ref} defines the judgments
$\flattenTerm{p}{\tiles^{\pat}}$
and
$\flattenTerm{e}{\tiles^{\expr}}$,
which specify how to ``flatten'' a tree-structured
term into a corresponding sequence of tiles.
We consider a tile sequence $\tiles^s$ to be well-formed
with respect to the underlying language if there exists
a language term that flattens to $\tiles^s$.

Showing the existence of such a language term
is equivalent to showing the tiles in $\tiles^s$
form a valid operator sequence.
Each tile may be interpreted as a component
of an operator sequence, taking one of four
different shapes: operand, unary prefix,
unary suffix, and binary infix...


\subsection{Actions}
We now present \ty's central action judgment
$\performAction{\editState_1}{\action}{\editState_2}$,
which sends edit state $\editState_1$ to $\editState_2$
via action $\alpha$.
The action judgment is governed by a syntactic sensibility
theorem (Theorem \note{ref}) that ensures that
the subject of every action-reachable edit state can
be parsed into language term.

\input{filter-tiles}
\input{whole-selection}
\input{action-syntax}
\input{action-judgment}

\note{
  Define actions more generally than \tylr~ implementation,
  such that delimiters are assigned sorts to their ends,
  selections are not restricted to shards and
  same-sort tiles, and only selections whose ends are the
  same may enter restructuring mode.
}

% (2 * [3])  ->  (2 * (3 + [_]))

\begin{itemize}
  \item explain action judgment + choice rules
  \item theorems
  \begin{itemize}
    \item movability
    \item selectability
    \item restructuring is sound and complete
  \end{itemize}
\end{itemize}

\subsection{Typechecking}
\note{
  Define tree-structured variants of tiles and frames.
  Define precedence parser that converts linear forms to tree forms
  (or assume existence of such parser?).
  Define type
}
