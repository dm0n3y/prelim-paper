% !TEX root = prelim-paper.tex

\section{Tile-based Editor Calculus}\label{sec:formalism}

We now present a precise specification of tile-based
editing in the form of a core calculus called \ty.

Edit states in \ty~ follow a variant
of the zipper pattern first described by Huet.
In particular, \ty~ edit states have a \emph{bottom-up}
zipper structure \note{cite}---consisting of a focused substructure
and, separately, its surrounding ``inside-out'' context---unlike
the top-down structure adopted in other work \note{cite}.
In this work, we call the focused substructure the \emph{subject} of
the zipper and its surrounding context the \emph{frame}.
Sections \note{ref} and \note{ref} present the syntax of
\ty~ subjects and frames as well as methods of disassembling
and reassembling these structures as needed for editing.

The punchline of \ty~ is the action judgment
$\performAction{\editState_1}{\action}{\editState_2}$ \note{section ref},
which sends edit state $\editState_1$ to $\editState_2$
via action $\alpha$.
These actions are governed by a syntactic sensibility theorem \note{ref},
which states that every action-reachable edit state can
be parsed into a language term.
Section \note{ref} presents the action judgment and characterizes
its metatheory.

\subsection{Tiles, tokens, \& selections}
We start with the syntax of the subject of a \ty~ edit state,
shown in Figure \note{ref}.
The subject may be in one of three \emph{modes}.
The first mode, called \emph{pointing mode}, models
a cursor sitting between a pair of \emph{selections},
each of which is a linear sequence of heterogeneously
sorted \emph{tiles} and \emph{tokens}.
We described the syntax of tiles
in the previous section (Figure \note{ref}).
Tokens are the lexical components of tiles, forming either
the substance of childless tiles or the delimiters of parent
tiles' children.
Tokens are generated from tiles via the \emph{tile disassembly} function
$\disassembleTile{\cdot}$, defined in Figure \note{ref},
which takes a tile and produces
a selection consisting of the tile's tokens
and the tile's children tiles.
% Such a permissive syntactic structure is not strictly necessary
% for modeling pointing mode, as \ty ensures that,
% in any action-reachable edit state in pointing mode,
% the selections consist entirely of tiles of the same sort;
% however, it is also useful for modeling intermediate
% edit states internal to the action semantics.

The second mode, called \emph{selecting mode},
consists of a user-specified selection in between
the unselected prefix and suffix selections.
Selecting mode models the user making a selection by
having dropped
an anchor at the selection's right end and moving
the cursor left to mark the left end.
For brevity, we ignore the mirror case.
% For the sake of brevity, we restrict our attention to selections
% specified by dropping an anchor at the right
% end of the selection and moving left to specify the
% left end; modeling the opposite case yields no new insights.

The third mode, called \emph{restructuring mode},
has the same structure as selecting mode.
It models the user having ``picked up'' a selection
and moving it to different target location within the
prefix and suffix selections.

% Selections may be arbitrarily structured, but we show
% in Section \note{ref} how \ty's actions ensure that,
% in any reachable edit state in pointing mode, the subject
% selections consist entirely of tiles of the same sort.

Selections have a permissive syntax, e.g., both
a singleton tile and its disassembly form valid selections.
Such a permissive syntax makes it possible to define
\ty's linear editing operations generically with
respect to the underlying language's tile grammar,
by flattening hierarchies into linear sequences and
operating directly on the flattened structures.
Between edits, however, we would like to ensure
that selections remain ``maximally assembled'' in order
to inform the user of the top-level structures they
are manipulating.
Hence, we need to define an appropriate parsing function
on selections that restores maximal structure as needed.

Tile disassembly induces a natural ordering relation
on selections.
We can lift tile disassembly to a step-disassembly relation
$\stepDisassembleSelection{\selection_1}{\selection_2}$
on selections, defined
in Figure \note{ref}.
This relation chooses a tile in $\selection_1$, disassembles
it, and splices it back in to produce $\selection_2$.
We can show that the reflexive transitive closure
$\searrow^*$ of $\searrow$ is a partial order in
which every selection has a unique maximal element
that disassembles to it.

\begin{lemma}
  $\searrow^*$ is a partial order.
\end{lemma}

\begin{lemma}\label{lemma:unique-parsed-selection}
  For every selection $\Psi$, there is a unique maximal
  element $\Psi'$ such that $\Psi'\searrow^*\Psi$.
\end{lemma}

Lemma \ref{lemma:unique-parsed-selection} makes it
possible to give a well-defined parsing function
on selections:
\begin{definition}
  Given a selection $\selection$, let $\parseSelection{\selection}$ be
  the unique maximal selection that disassembles
  to $\selection$.
\end{definition}


% The subject may be in one of three
% modes: \emph{pointing}, \emph{selecting}, and \emph{restructuring}.
% Each mode is made up of two or three \emph{selections}, each
% of which is a linear sequence of heterogeneously sorted
% \emph{tiles} and \emph{tokens}.
% Recall that the syntax of tiles was presented in Figure \note{ref}
% of the previous section.
% Tokens are the lexical components of tiles, forming either
% the substance of childless tiles or the delimiters of parent
% tiles' children.
% % Under \ty's actions, they appear in the subject
% % as untethered delimiters of tiles divided by a selection boundary.
% Tokens are generated from tiles via the \emph{tile disassembly} function
% $\disassembleTile{\cdot}$, defined in Figure \note{ref},
% which takes a tile and produces
% a selection consisting of the tile's tokens
% and the tile's children tiles.


\input{token-syntax}
\input{selection-syntax}
\input{disassemble-tile}
\input{disassemble-selection}

\note{make clear parallel between CFG derivation and disassembly}

\subsection{Frames \& zippers}
Now we turn to the syntax of \emph{frames}, presented
in Figure \note{ref}.
Given a subject of focus in a \ty~ edit state, the frame
represents the surrounding context making up the rest of the program.
Frames are structured in a bottom-up fashion, starting
with the nearest containing structure and concluding
with the program root.
Each frame specifies the sort of tiles with which it is
expected to be filled.
For example, if the edit subject is located at $\Box$
in the program \texttt{let x = ( $\Box$ ) + 1 in x + 2},
then the frame is modeled by our syntax as
\[
  \tframelit{
    \sparen{\_}
  }{
    \tframelit{
      \_\splus{}{\texttt{1}}
    }{
      \tframelit{
        \slet{\texttt{x}}{\_}{}
      }{
        \tframelit{
          \_\ \splus{\texttt{x}}{\texttt{2}}
        }{
          \note{root}
        }
      }
    }
  }
\]
Notice that frames alternate between \emph{tile
frames} that form bidelimited containers and
\emph{sequence frames} consisting of the tiles
surrounding each tile frame.

Having defined subjects and frames, we may now
define the syntax of edit states,
shown in Figure \note{ref}.
An edit state consists of a sort-indexed \emph{zipper},
each consisting of a subject and a frame of the
specified sort.

Like tiles, frames may be decomposed into their
lexically constituent tiles and tokens via the
\emph{frame disassembly} function $\disassembleTileFrame{\cdot}$,
defined in Figure \note{ref}.
Similar to how we lift tile disassembly to selection
disassembly, we can lift frame disassembly to
\emph{edit state disassembly}, defined in Figure \note{ref}.
We can show that the reflexive transitive closure
$\nearrow^*$ of $\nearrow$ is a partial order in
which every edit state with a subject in pointing mode
has a unique minimal element that disassembles to it:
\begin{lemma}
  $\nearrow^*$ is a partial order.
\end{lemma}
\begin{lemma}\label{lemma:unique-parsed-editstate}
  For every zipper $\zip^s_1 = \zipper{\pointing{\selection_1}{\selection_2}}{\tfrelem^s}$, there exists
  a unique minimal element $\zip^s_2$ such that $\zip^s_2 \nearrow^* \zip^s_1$.
\end{lemma}

Lemma \ref{lemma:unique-parsed-editstate} makes it
possible to give a well-defined parsing function
on edit states with a pointing mode subject:

\begin{definition}
  Given an edit state $\editState = \zipper{\pointing{\selection_1}{\selection_2}}{\tfrelem^s}$,
  let $\parseZipper{\editState}$ be the unique minimal edit state
  that disassembles to $\editState$.
\end{definition}

\input{frame-syntax}
\input{zipper-syntax}
\input{disassemble-frame-tile}
\input{step-disassemble-zipper}

% \begin{definition}
%   $\zeta^s_1\nearrow\zeta^s_2$ if $\disassembleTileFrame{\zeta^s_1} = \zeta^s_2$.
%   \note{defined this for symmetry with diassembling of tiles}
% \end{definition}

% \begin{definition}
%   $\nearrow^*$ is the reflexive transitive closure of $\nearrow$.
% \end{definition}

\input{tip-syntax}
% \input{fix-holes-judgment}
\input{hole-fixing-judgment}
\input{filter-tiles}
\input{whole-selection}
\input{action-syntax}
\input{action-judgment}

\subsubsection{Actions}
\note{
  Define actions more generally than \tylr~ implementation,
  such that delimiters are assigned sorts to their ends,
  selections are not restricted to shards and
  same-sort tiles, and only selections whose ends are the
  same may enter restructuring mode.
}

% (2 * [3])  ->  (2 * (3 + [_]))

\begin{itemize}
  \item explain action judgment + choice rules
  \item theorems
  \begin{itemize}
    \item movability
    \item selectability
    \item restructuring is sound and complete
  \end{itemize}
\end{itemize}

\subsection{Typechecking}
\note{
  Define tree-structured variants of tiles and frames.
  Define precedence parser that converts linear forms to tree forms
  (or assume existence of such parser?).
  Define type
}
