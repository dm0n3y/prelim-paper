% !TEX root = prelim-paper.tex

\section{Tile-based Editor Calculus}\label{sec:formalism}

We now precisely characterize tile-based editing
as a calculus called \ty.
The punchline of \ty~ (Section \ref{sec:actions})
is the action judgment
$\performAction{\editState_1}{\action}{\editState_2}$,
which sends edit state $\editState_1$ to $\editState_2$
via action $\action$; and its governing invariants,
which state that every action-reachable edit state
can be parsed into a well-formed program term.

Edit states $Z$ follow a variant of the well-known \emph{zipper}
pattern \cite{zipper}, which decomposes a structure of interest
into a focused substructure $B$ and its surrounding context $M$.
In this work, we refer to $B$ as the \emph{subject}
and $M$ as the \emph{frame}.
\[
\arraycolsep=4pt
\begin{array}{rlrl}
  \text{zipper} & \zip & ::= & \zipper{\subject}{\zframe}
\end{array}
\]
Our design diverges from prior art in our pursuit
of linear text-like interactivity.
Prior zipper designs are strictly hierarchical and ask
the client to navigate in a structure-aware two-dimensional
fashion: left and right to traverse siblings,
up and down to traverse parent-child relations.
In contrast, we aim to support a one-dimensional interaction
model:
it should be possible to navigate freely by moving solely
left and right \note{might need to clarify or change wording
here to address comparison with ordered traversals of trees};
furthermore it should be possible to specify
arbitrary subranges of a one-dimensional serialization
of the total structure.
Toward these ends, actions in \ty~ rely
on a form of incremental unparsing and reparsing by which
hierarchical structures may be ``flattened'' as needed
to support linear traversal and partial selection.

Our presentation in this section builds upon the term and tile syntax
described earlier in Figure \ref{fig:term-tile-syntax} of
Section \ref{sec:overview}.
\begin{enumerate}
  \item[\textbf{\ref{sec:shards-and-pieces}}]
  We will begin by formally introducing shards
  and describing their relation to tiles via disassembly
  and reassembly.

  \item[\textbf{\ref{sec:tips-and-terms}}]
  We will then describe how tiles and shards relate to
  terms. In particular, we will show that
  we can successfully parse a sequence of tiles
  into a term provided that they ``fit'' together in
  certain ways.

  \item[\textbf{\ref{sec:subjects-and-frames}}]
  As a result, we need not limit ourselves to
  the highly structured terms
  but can instead organize our zippers around the
  more flexible tiles and shards.

  \item[\textbf{\ref{sec:actions}}]
  This paves the way for linear navigation and
  flexible selection when we define actions operating
  on zippers.
  Meanwhile, by taking care to
  maintain proper ``fit'' and shard assemblage along the
  way, actions ensure that reachable edit states can
  be successfully parsed into a program term.

\end{enumerate}


% We will begin in Section \ref{sec:terms-tiles-tips} by
% describing how tiles can be disassembled into shards,
% and how a sequence of tiles and shards is parseable
% into a well-formed term provided they ``fit'' together;
% in other words, \ty~ edit states and actions need not
% deal directly with the term syntax to enforce well-formedness.
% Having introduced the ingredients necessary for subjects,
% we will then describe frames in
% Section ?? and how they, too, can be disassembled and
% reassembled as needed.
% Finally, Section ?? will give the punchline.
% \note{revisit this paragraph and rework to more explicitly
% note subject/frame organization, also mention zipping}

% In particular, they have a \emph{bottom-up} zipper structure---consisting
% of a focused substructure $\subject$ and, separately, its surrounding
% ``inside-out'' context $\zframe$---

% \note{add some high level preview about edit states, zippers,
% justify this organization so that people are happy to wait;
% consider giving an example right away as I discuss bottom-up zippers}

% Parsing in \ty~ is stratified into two phases:
% assembling shards into tiles, and precedence-parsing
% tiles into terms.
% We will begin in Section \ref{sec:terms-tiles-tips}
% by showing that the precedence-parsing phase is
% guaranteed to succeed provided each element of the
% input sequence ``fits'' its neighbors.
% \note{sort of misleading, ignores children}
% As a result, we can structure \ty~ edit states using
% tiles rather than terms (Section \ref{sec:edit-states}),
% and the actions operating on edit states need only
% concern themselves with shard assembly and fixing holes
% to maintain sequential ``fit'' (Section \ref{sec:actions}).

% \note{something about how both of these parsing steps
% deviate from the usual approach of parsing, which takes
% a sequence of characters or tokens and produces a
% parse tree, whereas here we have more fine-grained
% delineation between different parseable/parsed structures,
% which is why we take care in this section to define
% derivations from one structure to another}

\subsection{Shards and pieces} \label{sec:shards-and-pieces}

Given below is the syntax for shards corresponding to the tiles
in Figure \ref{fig:tile-syntax}.
\input{shard-syntax}

\noindent \note{give an example of shard, note that
we don't model all shards that show up in overview and
that we'll discuss this when we talk about extensions}
Collectively we refer to shards and tiles as \emph{pieces}.
\input{pieces-syntax}

% \noindent
% \note{something about pieces being quite flexible, forward
% referencing Section \ref{sec:sec:subjects-and-frames} and
% nothing how they make it easy to encode partial selections
% as well as intermediate disassembled edit states
% between input and output edit states of an action}

\input{subject-disassembly}

We can produce shards from tiles via \emph{step-disassembly},
as defined for pieces and pseqs in Figure \ref{fig:subject-disassembly}.
The first judgment $\pieceDisassembles{\selem}{\selection}$
step-disassembles a piece $\selem$ into a sequence of
its constituent shards and children tiles.
The second judgment $\stepDisassembleSelection{\selection_1}{\selection_2}$
chooses a piece in $\selection_1$ and replaces it with its
step-disassembly in-place to produce $\selection_2$.
The reflexive transitive closure $\tpiecesdd^*$ of
$\tpiecesdd$ we call \emph{disassembly}.

Disassembly of pieces is analogous to string derivation for a
context-free grammar (CFG),
where a string containing terminal and nonterminal symbols is iteratively
rewritten according to the grammar rules.
A parser for a CFG may then be characterized as a function
that takes a string of terminal symbols and identifies
a derivation from the grammar's starting nonterminal
symbol to the input string, if any exist.
We may similarly characterize a parser on pieces according
to the disassembly relation.
In this case, however, our parsing goal is \emph{maximal}
rather than \emph{maximum} structure, \ie, the parser
need not identify a disassembly connecting the input
shards to unbroken tiles (the start symbol), but need only assemble shards
together opportunistically.
\note{too hand-wavey, come back and revise}

More precisely, we can show that disassembly is a
partial order, and that every pseq in this order
has a unique maximal element that diassembles to it.
\begin{lemma}
  $\tpiecesdd^*$ is a partial order.
\end{lemma}
\begin{lemma}\label{lemma:unique-parsed-selection}
  For every piece sequence $\selection$, there is a unique
  sequence $\selection'$ such that:
  \begin{itemize}
  \item $\selection'\searrow^*\selection$, and
  \item $\selection'$ is maximal: if $\selection''\searrow^*\selection'$ then $\selection'' = \selection'$.
  \end{itemize}
\end{lemma}
\noindent
These results allow us to specify, in an algorithm-independent
fashion, a well-defined \emph{assembly} function.
\begin{definition}
  Given pieces $\selection$, let $\parseSelection{\selection}$ be
  the unique maximal pseq that disassembles to $\selection$.
\end{definition}
\noindent
We defer presenting a constructive implementation of this function
to the imaginary appendix.


\subsection{Tips and terms} \label{sec:tips-and-terms}

\input{term-flattening}
\input{tip-syntax}

\begin{definition}
  A selection $\selection$ is an \emph{opseq of sort $s$} if
  it is intact and $\lltip{s}~\rrtip{s}$-connected.
\end{definition}

\begin{theorem}
  A selection $\selection$ is an opseq of sort $s$
  if and only if there exists a term $x$ of sort $s$ such that
  $\flattenTerm{x}{\selection}$.
  \note{todo: sort-indexed term notation}
\end{theorem}

Finally we establish the connection between
\ty~ edit states and \emph{terms} of the
underlying language, as are typically defined
with a strictly tree-structured abstract syntax.
Figure \note{ref} shows the abstract syntax of
\ty~ language terms;
this syntax coincides with that in Figure \note{ref}
except for the inclusion of a new operator hole term
to account for operator holes in the tile syntax.

Figure \note{ref} defines the judgments
$\flattenTerm{p}{\tiles^{\pat}}$
and
$\flattenTerm{e}{\tiles^{\expr}}$,
which specify how to ``flatten'' a tree-structured
term into a corresponding sequence of tiles.
We consider a tile sequence $\tiles^s$ to be well-formed
with respect to the underlying language if there exists
a language term that flattens to $\tiles^s$.
\note{talk a bit about the parentheses rule, note that this is just for stating theorem}

Showing the existence of such a language term
is equivalent to showing the tiles in $\tiles^s$
form a valid operator sequence.
Each tile may be interpreted as a component
of an operator sequence, taking one of four
different shapes: operand, unary prefix,
unary suffix, and binary infix...



\subsection{Subjects and frames} \label{sec:subjects-and-frames}
\input{edit-state-syntax}

\note{set up running example right away}

We start with an overview of the syntax of \ty~ edit states,
presented altogether in Figure \ref{fig:edit-state-syntax}.
Edit states in \ty~ are sort-indexed structures
$\zipper{\subject}{\tfrelem^s}$ that follow a variant
of the zipper pattern first described by Huet.
In particular, they have a \emph{bottom-up}
zipper structure \note{cite}---consisting of a focused substructure
$\subject$ and, separately,
its surrounding ``inside-out'' context $\tfrelem^s$---unlike
the top-down structure adopted in other work \note{cite}.
In this work, we call the focused substructure the \emph{subject} of
the zipper and its surrounding context the \emph{frame}.

\subsubsection{Tiles, tokens, \& selections}
The subject $\sigma$ of a zipper $\zipper{\subject}{\tfrelem^s}$
may be in one of three modes.
\note{name them here}
We defer higher-level discussion regarding their roles in
editing to Section \note{ref}, where we define \ty's editing
operations, and focus now on the structures that constitute them.

% The first mode, called \emph{pointing mode}, consists of
% a pair of tiles of the sort expected by the frame.
% We described the syntax of tiles
% in Section \ref{sec:overview};
% the same syntax that was presented in Figure \note{ref}
% is presented again in Figure \note{ref} in context.

% The second and third modes, called \emph{selecting mode}
% and \emph{restructuring mode}, each consist of a trio of
% \emph{selections}.

\note{add back some discussion of tiles/tokens here}

All three modes consist of two or more \emph{selections}.
A selection is a linear sequence of heterogeneously
sorted \emph{tiles} and \emph{tokens}.
We described the syntax of tiles $\tile^s$
in Section \ref{sec:overview};
the same syntax that was presented in Figure \ref{fig:tile-syntax}
is presented again in Figure \ref{fig:edit-state-syntax} in context.
Tokens $\shard^s$ are the lexical components of tiles, forming either
the substance of childless tiles or the delimiters of parent
tiles' children.
Tokens are generated from tiles via the \emph{tile disassembly} function
$\disassembleTile{\cdot}$, defined in Figure \ref{fig:disassemble-tile},
which takes a tile and produces
a selection consisting of the tile's tokens
and the tile's children tiles.
\note{need more examples}

\note{find different phrasing here that doesn't invite interpretation as technical terms}
Selections have a permissive syntax, with multiple
ways of representing the same essential content.
For example, both a singleton tile and the tile's disassembly
form valid selections.
\note{make this a real example}
Such a permissive syntax is useful for representing
arbitrary divisions of a program's
lexical components, but we would like to ensure
that the divided selections remain ``maximally assembled''
in order to inform the user of the top-level structures
they are manipulating.
\note{give explicit examples of divisions showing maximally
and non-maximally assembled selections}

This calls for defining an appropriate
parser on selections to maintain
maximal structure as they grow and shrink during editing.
\note{make this more precise "when the selection changes",
perhaps add another example here of a selection growing}
Such a parser cannot be specified in the standard way
with a context-free grammar because such parsers are
all-or-nothing, whereas in our case our parser should
produce structure opportunistically while not requiring any
specific top-level form.
\note{maybe don't talk about this here, if anything talk about
it after I define what we did}
Much as a CFG-based parser identifies a derivation from
the CFG's start symbol to the input string,
our selection parser identifies an analogous ``disassembly'' from
a maximally structured selection to the input selection.
\note{more example}

\subsubsection{Frames \& zippers}
The sort-indexed frame $\tfrelem^s$ of a zipper
$\zipper{\subject}{\tfrelem^s}$ models the rest of
the program surrounding the subject $\subject$,
the sort index $s$ specifying what sort is expected
of the subject.
Frames are nested in bottom-up fashion, starting
with the nearest containing structure and concluding
with the program root.
For example, if the edit subject is located at $\Box$
in the program \texttt{let x = ( $\Box$ ) + 1 in x + 2},
then the frame is represeted in our syntax as
\[
  \tframelit{
    \sparen{\_}
  }{
    \tframelit{
      \_\splus{}{\texttt{1}}
    }{
      \tframelit{
        \slet{\texttt{x}}{\_}{}
      }{
        \tframelit{
          \_\ \splus{\texttt{x}}{\texttt{2}}
        }{
          \note{root}
        }
      }
    }
  }
\]
Notice that frames alternate between \emph{tile
frames} $\tfrelem^s$ that form bidelimited containers and
\emph{sequence frames} $\tframe^s$ consisting of the tiles
surrounding each tile frame.

% Having defined subjects and frames, we may now
% define the syntax of edit states,
% shown in Figure \note{ref}.
% An edit state consists of a sort-indexed \emph{zipper},
% each consisting of a subject and a frame of the
% specified sort.

% \input{frame-syntax}
% \input{zipper-syntax}
\input{disassemble-frame-tile}
\input{step-disassemble-zipper}

Like tiles, frames may be decomposed into their
lexically constituent tiles and tokens via the
\emph{frame disassembly} function $\disassembleTileFrame{\cdot}$,
defined in Figure \note{ref}.
Similar to how we lift tile disassembly to selection
disassembly, we can lift frame disassembly to
\emph{edit state step-disassembly}, defined in Figure \note{ref}.
We can show that the reflexive transitive closure
$\nearrow^*$ of $\nearrow$, which we call \emph{edit state disassembly},
is a partial order in
which every edit state with a subject in pointing mode
has a unique minimal element that disassembles up to it:
\begin{lemma}
  $\nearrow^*$ is a partial order.
\end{lemma}
\begin{lemma}\label{lemma:unique-parsed-editstate}
  For every edit state $\editState = \zipper{\pointing{\selection_1}{\selection_2}}{\tfrelem^s}$,
  there exists a unique $\editState' = \zipper{\pointing{\selection'_1}{\selection'_2}}{\tfrelem^{s'}}$ such that
  \begin{itemize}
  \item $\editState' \nearrow^* \editState$, and
  \item if $\editState'' \nearrow^* \editState'$ then $\editState'' = \editState'$.
  \end{itemize}
\end{lemma}
Lemma \ref{lemma:unique-parsed-editstate} makes it
possible to specify a well-defined parsing function
on edit states in pointing mode:
\begin{definition}
  Given an edit state $\editState = \zipper{\pointing{\selection_1}{\selection_2}}{\tfrelem^s}$,
  let $\parseZipper{\editState}$ be the unique minimal edit state
  that disassembles up to $\editState$.
\end{definition}

% \begin{definition}
%   $\zeta^s_1\nearrow\zeta^s_2$ if $\disassembleTileFrame{\zeta^s_1} = \zeta^s_2$.
%   \note{defined this for symmetry with diassembling of tiles}
% \end{definition}

% \begin{definition}
%   $\nearrow^*$ is the reflexive transitive closure of $\nearrow$.
% \end{definition}

\subsection{Actions} \label{sec:actions}

\note{add invariants for all modes, or consider
modifying restructuring movement to take into account
sort (but emphasize what is obligatory as you scale)}

We now present \ty's central action judgment
$\performAction{\editState_1}{\action}{\editState_2}$,
which sends edit state $\editState_1$ to $\editState_2$
via action $\action$.
The action judgment is governed by a syntactic sensibility
theorem (Theorem \note{ref}) that ensures that
the subject of every action-reachable edit state can
be parsed into language term.

% \input{fix-holes-judgment}
\input{hole-fixing-judgment}

\input{filter-tiles}
\input{whole-selection}
\input{action-syntax}

\input{move-pointing}
\input{move-selecting}
\input{move-restructuring}
\input{action-judgment}

\note{
  Define actions more generally than \tylr~ implementation,
  such that delimiters are assigned sorts to their ends,
  selections are not restricted to shards and
  same-sort tiles, and only selections whose ends are the
  same may enter restructuring mode.
}

% (2 * [3])  ->  (2 * (3 + [_]))

\begin{itemize}
  \item explain action judgment + choice rules
  \item theorems
  \begin{itemize}
    \item movability
    \item selectability
    \item restructuring is sound and complete
  \end{itemize}
\end{itemize}

\begin{theorem}
  Suppose $Z = \zipper{\subject}{\tfrelem^s}$ is a reachable edit state.
  \begin{enumerate}
  \item[(1)] If $\subject = \pointing{\selection_1}{\selection_2}$,
    then $\selection_1\selection_2$ is an opseq of sort $s$.
  \item[(2)] If $\subject = \selecting{\selection_1}{\selection_2}{\selection_3}$,
    then $\parseSelection{\selection_1\selection_2\selection_3}$ is an opseq of sort $s$.
  \item[(3)] If $\subject = \restructuring{\selection_1}{\selection_2}{\selection_3}$...
    \begin{enumerate}
      \item[(a)] ...and $\selection_2$ is intact, then
        $\selection_1\selection_3$ is an opseq of sort $s$.
      \item[(b)] ...and $\selection_2$ is cracked, then
        $\parseSelection{\selection_1\selection_2\selection_3}$ is an opseq of sort $s$.
    \end{enumerate}
  \end{enumerate}
\end{theorem}

\begin{theorem}

\end{theorem}

% \subsection{Typechecking}
% \note{
%   Define tree-structured variants of tiles and frames.
%   Define precedence parser that converts linear forms to tree forms
%   (or assume existence of such parser?).
%   Define type
% }
