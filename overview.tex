\section{Overview}\label{sec:overview}


\begin{figure*}
  \centering
  % \begin{minipage}{0.25\textwidth}
  %   \begin{subfigure}[t]{\textwidth}
  %     \includegraphics[width=\textwidth]{img/circles-n-n-1.png}
  %   \end{subfigure}
  % \end{minipage}
  % \hfill
  % \begin{minipage}{0.35\textwidth}
    \begin{subfigure}[b]{0.35\textwidth}
      \[
    \arraycolsep=3pt\begin{array}{rlrl}
        \text{pattern} & \spat & ::= &
          \shole ~\vert~
          \svar{x} ~\vert~
          \sprod{\spat}{\spat}\\
        \text{expression} & \sexp & ::= &
          \shole ~\vert~
          \snumlit{n} ~\vert~
          \svar{x} \\
        & & \vert &
          % \sap{\sexp}{\sexp} ~\vert~
          \sprod{\sexp}{\sexp} ~\vert~
          \splus{\sexp}{\sexp} ~\vert~
          \smult{\sexp}{\sexp} \\
        & & \vert &
          \slam{\spat}{\sexp} ~\vert~
          \slet{\spat}{\sexp}{\sexp}
    \end{array}\]
    \caption{}
    \label{fig:term-syntax}
  \end{subfigure}
  \hspace{1cm}
  \begin{subfigure}[b]{0.35\textwidth}
    \centering
    \[\arraycolsep=3pt\begin{array}{rlrl}
        \text{tile sequence} & \tiles^s & ::= & \tile^s_1\dots\tile^s_n \\
        \text{pattern tile} & \tile^{\pat} & ::= &
          \ophole ~\vert~
          \svar{x} ~\vert~
          \sparen{\tiles^{\pat}} ~\vert~
          \binhole ~\vert~
          \sprod{}{} \\
        \text{expression tile} & \tile^{\expr} & ::= &
          \ophole ~\vert~
          \snumlit{n} ~\vert~
          \svar{x} ~\vert~
          \sparen{\tiles^{\expr}} ~\vert~
          \binhole ~\vert~
          % \sap{}{} ~\vert~
          \sprod{}{} ~\vert~
          \splus{}{} ~\vert~
          \smult{}{} \\
        & & \vert &
          \slam{\tiles^{\pat}}{} ~\vert~
          \slet{\tiles^{\pat}}{\tiles^{\expr}}{}
      \end{array}\]
      \caption{}
      \label{fig:tile-syntax}
    \end{subfigure}
    \vspace{1cm}

   \begin{subfigure}[c]{0.25\textwidth}
      \centering
      \includegraphics[width=0.9\textwidth]{img/pan-terms-0.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-1.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-2.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-3.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-4.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-5.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-6.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-7.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-8.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-9.png}
      \includegraphics[width=0.9\textwidth]{img/pan-terms-10.png}
      \caption{}
      \label{fig:pan-term-view}
  \end{subfigure}
  \begin{subfigure}[c]{0.45\textwidth}
    \centering
    \includegraphics[width=0.75\textwidth]{img/circles-n-n-1.png}
    \caption{}
    \label{fig:default-circles}
  \end{subfigure}
  \begin{subfigure}[c]{0.25\textwidth}
    \centering
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-0.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-1.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-2.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-3.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-4.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-5.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-6.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-7.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-8.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-9.png}
    \includegraphics[width=0.9\textwidth]{img/pan-tiles-10.png}
    \caption{}
    \label{fig:pan-tile-view}
  \end{subfigure}
  % \end{minipage}
\end{figure*}

% \input{term-syntax}
% \input{tile-syntax}

We now present an example-driven overview of tile-based
editing using \tylr.

\note{consider a parens teaser example in the intro}

\note{consider having some explanation why I'm not starting from hole}
\note{maybe just edit the following sentence so I'm editing given function, not defining afresh}

\note{try splitting section into subsections by features}

\note{make clear the invariant of syntactic sensibility at the start, use it as a guide}

Suppose you are using \tylr~ to edit a function that gets called by a
generative drawing application \note{cite Sketch n Sketch}.
\note{use word ``exploratory here''}
The function takes an integer index and
return a circle---represented as a pair comprising
its center point and radius---to be drawn in
the $xy$-plane for every index.
The initial implementation, shown below, draws circles
of radius \texttt{1} along the line $y = x$.

\subsection{Tiles}
Panning your cursor over the program in \tylr ,
as shown in Figure \ref{fig:pan-term-view},
reveals outlined terms of \tylr's concrete syntax,
the relevant subset of which is shown in
Figure \ref{fig:term-syntax}.

Highlighted at the root of every term is a structure called
a \emph{tile}.
The tile encompasses all tokens and delimiters used to represent
the root form of the term (e.g., \texttt{1} for a number literal,
$\lambda$ and \texttt{.} for lambda terms,
\texttt{(} and \texttt{)} for parenthesized terms) along with
all children terms delimited on both sides (\eg,
the bidelimited pattern child \texttt{n} of the lambda term,
the bidelimited expression child \texttt{n , n} of
the parenthesized term).
Tiles are color-coded by sort---green for expressions, blue
for patterns---and shaped such that they enclose bidelimited
child terms of different sort and leave unenclosed bidelimited
child terms of the same sort.

Tiles are shaped at their ends to fit together sequentially
into operator sequences.
% \begin{align*}
% \langle\overline{\underline{\text{operand}}}\rangle,
% \langle\overline{\underline{\text{prefix operator}}}\langle, \\
% \rangle\overline{\underline{\text{postfix operator}}}\rangle,
% \rangle\text{infix operator}\langle.
% \end{align*}
Holding Alt/Option at any time reveals the local tile sequence
housing the cursor, as shown in Figure \ref{fig:pan-tile-view}.
Where other structure editors model their edit states
using the strictly hierarchical term syntax,
\tylr~ instead models its edit state
using the flattened tile syntax, parsing the tile structure
as needed to produce the term structure.
Indeed, the apparent term structure shown in Figure
\ref{fig:pan-term-view} is simply a
decoration overlaid atop the actual tile structure shown in
Figure \ref{fig:pan-tile-view}.

\note{add discussion of tile structure well-formedness,
discuss sort-colored cursor positions}

\note{need to define pointing mode}

% Tiles are closely related to nested words \note{cite} and
% visibly pushdown languages \note{cite}, which we discuss
% further in Section \ref{sec:related-work}.

\subsection{Inserting tiles}
By having you edit the tile structure, and only
indirectly propagate those edits to the term structure,
\tylr~ recovers many of the flexible editing affordances to
which you are accustomed in a text editor.
For example, say you update the function to
draw circles along the parabola $y = x^2/9$,
accomplished via the following edit sequence:

\noindent
\begin{minipage}[t]{0.2\columnwidth}
  \includegraphics[width=\textwidth]{img/circles-parabola.png}
\end{minipage}
\hfill
\begin{minipage}{0.65\columnwidth}
  \includegraphics[width=\textwidth]{img/linear-insertion-0.png}
  \includegraphics[width=\textwidth]{img/linear-insertion-1.png}
  \includegraphics[width=\textwidth]{img/linear-insertion-2.png}
  \includegraphics[width=\textwidth]{img/linear-insertion-3.png}
  \includegraphics[width=\textwidth]{img/linear-insertion-4.png}
\end{minipage}

You constructed the operator sequence \texttt{n * n / 9}
by typing left-to-right, as you might in a text editor, without any
required consideration for its tree structure.
Such an affordance is not trivial
in traditional structure editors because,
from the perspective of the AST, linear construction of
operator sequences is a complex, context-sensitive operation.
Existing structure editors either embrace strictly tree-based
construction of operator sequences;
defer to text at the expression level,
recovering linearity at the cost of structure;
or solve the problem at the cost of complexity
(e.g. side transforms in MPS).
Tiles enable linear editing of operator sequences,
while continuously maintaining structure and
relying on simple precedence parsing
to update the operator sequence's associative structure
as you type.

\note{note that this is insertion, not ``hole filling'' as
it is traditionally conceived in structure editors}

\note{figure out way to say wholesale but not being whole program}

\note{insert a comment somewhere about no performance claims}

\note{review side transforms and make sure I'm not BSing}


\note{figure out where to talk about hole insertion based on tips
somewhere here}

% \tylr~ takes a different approach to this problem.
% Where traditional structure editors simply expose editing
% operations acting directly on the abstract syntactic struture
% of a program, \tylr~ presents the program in a separate
% concrete syntax with its own syntax-directed editing operations.
% \note{
%   talk about tile syntax show in Figure \ref{fig:tile-syntax},
%   note linearity
% }
% Like text, \tylr's concrete syntax gives you ``flattened''
% representation of your program that can be edited in a linear fashion.
% Unlike text, the concrete syntax maintains hierarchies of
% bidelimited children and can always be parsed into
% the abstract syntax, provided that the structure first undergoes
% a hole fixing pass in which holes are inserted and removed
% as needed. \note{need more context about tiles + bidelimited, bring
% back some old words about abstract syntactic structural units
% as opposed to concrete syntactic structural units}

% \note{perhaps go back to editor syntax terminology}

\begin{figure*}
  \begin{tabular}{cp{0.7\textwidth}}
  \includegraphics[width=0.1\textwidth]{img/circles-parabola-grow-1.png}
  &
  {
    \begin{align*}
      & \texttt{$\lambda$ n . let x , y = \_|in ( n * n / 9 , n ) , 1} \\
      & \texttt{$\lambda$ n . let x , y = \_|in|( n * n / 9 , n ) , 1} \\
      & \texttt{$\lambda$ n . let x , y = [in]( n * n / 9 , n ) , 1} \\
      & \texttt{$\lambda$ n . let x , y = ( n * n / 9 , n )[in], 1} \\
      & \texttt{$\lambda$ n . let x , y = ( n * n / 9 , n )|in \_ , 1} \\\\
      & \texttt{$\lambda$ n . let x , y = ( n * n / 9 , n|) in x , y , 1 } \\
      & \texttt{$\lambda$ n . let x , y = ( n * n / 9 , n|)|in x , y , 1 } \\
      & \texttt{$\lambda$ n . let x , y = |(|n * n / 9 , n[)]in x , y , 1 } \\
      & \texttt{$\lambda$ n . let x , y = |(|[)]n * n / 9 , n in x , y , 1 } \\
      & \texttt{$\lambda$ n . let x , y = [(][)]n * n / 9 , n in x , y , 1 } \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in [(][)]x , y , 1 } \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y[)], 1 } \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y|) , 1 } \\\\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y ) ,|x + y } \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y ) ,|(|[)]x + y } \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y ) ,|(|x + y[)]} \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y ) , ( x + y|)} \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y ) , ( x + y )|} \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y ) , ( x + y ) /|\_} \\
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n in ( x , y ) , ( x + y ) / 4|}
    \end{align*}
  }
  \end{tabular}
\end{figure*}

\begin{figure*}
  \begin{tabular}{cp{0.7\textwidth}}
  \includegraphics[width=0.1\textwidth]{img/circles-parabola-grow-2.png}
  &
  {
    \begin{align*}
      & \texttt{$\lambda$ n . let x , y = n * n / 9 , n|in ( x , y ) , n / 3} \\
      & \texttt{$\lambda$ n .|let x , y =|n * n / 9 , n[in] ( x , y ) , n / 3} \\
      & \texttt{$\lambda$ n . n * n / 9 , n|\_ ( x , y ) , n / 3} \\
      & \texttt{$\lambda$ n . n * n / 9 , n \_ (|x , y ) , n / 3} \\
      & \texttt{$\lambda$ n . n * n / 9 , n \_ (|x , y|) , n / 3} \\
      & \texttt{$\lambda$ n . n * n / 9 , n \_ (|\_ ) , n / 3} \\
      & \texttt{$\lambda$ n . n * n / 9 , n [(]|)|, n / 3} \\
      & \texttt{$\lambda$ n .[(]n * n / 9 , n|)|, n / 3} \\
      & \texttt{$\lambda$ n .|( n * n / 9 , n ), n / 3}
    \end{align*}
  }
  \end{tabular}
\end{figure*}

\subsection{Selecting and restructuring}
Tiles not only simplify linear \emph{insertion} in a structured
context but also enable text-like \emph{selecting}
and \emph{restructuring} (e.g. cut and paste) of existing code.
While the former problem is relatively well-studied
\note{cite MPS, modeless structure editing},
almost no attention has been paid to the latter.
In particular, all prior structure editors restrict
structured selections to complete concrete syntactic terms,
a severe limitation compared to the arbitrary range
selections of text editors.

\tylr~ recovers much of this lost flexibility.
Using \tylr's \emph{selecting mode}, you can
make arbitrary range selections up to token boundaries,
disassembling tiles into \emph{shards} as needed.
Using \tylr's \emph{restructuring mode},
you can pick up your selections into your
\emph{backpack} and put them down elsewhere,
Ã  la cut-and-paste using the clipboard.
Unlike the usual clipboard, however,
your backpack is structure-aware and guides your
movement toward valid paste targets, \ie,
you can only put down your backpack's contents
where the result can be reassembled into well-formed tiles.

\paragraph{Restructuring with a full backpack}
Say you update your circle drawing
to its transposition, i.e., draw the circles along
the parabola $x = y^2/9$.
Entering selecting mode, you anchor the selection's right
end and move left to select the tiles you just
inserted in the $y$-coordinate---an impossible
selection in prior structure editors.

\noindent
\begin{minipage}[t]{0.2\columnwidth}
  \includegraphics[width=\textwidth]{img/circles-parabola-transpose.png}
\end{minipage}
\hfill
\begin{minipage}{0.65\columnwidth}
  \includegraphics[width=\textwidth]{img/selection-whole-0.png}
  \includegraphics[width=\textwidth]{img/selection-whole-1.png}
  \includegraphics[width=\textwidth]{img/selection-whole-2.png}
  \includegraphics[width=\textwidth]{img/selection-whole-3.png}
  \includegraphics[width=\textwidth]{img/selection-whole-4.png}
\end{minipage}
You then pick it up into your backpack to enter
restructuring mode.
Moving left to the $x$-coordinate and putting down
the selection completes the desired transformation.

\noindent
\begin{tabular}{cp{7cm}}
\includegraphics[width=2cm]{img/circles-parabola-transpose.png}
&
{
\begin{align*}
  & \texttt{$\lambda$ n . ( n , n[* n / 9]) , 1} \\
  & \texttt{$\lambda$ n . ( n ,[* n / 9]n ) , 1} \\
  & \texttt{$\lambda$ n . ( n[* n / 9], n ) , 1} \\
  & \texttt{$\lambda$ n . ( n|* n / 9 , n ) , 1}
\end{align*}
}
\end{tabular}

We say that your backpack is \emph{full} whenever
its contents are, or can be assembled into, whole tiles.
If your backpack is full, then you may move freely,
since you may insert a selection of whole tiles anywhere and
still have a valid nested tile structure.
\tylr~ would have prevented you from putting
down your selection of expression tiles in a pattern
position; we discuss sort conversions in Section ??.
\note{awkward ending}

Often, however, your backpack's contents are not whole
tiles, nor can they be assembled into tiles.
In that case, we say that your backpack is \emph{hungry}.

\paragraph{Restructuring with a hungry backpack}

Say now you would like the circles' radii to grow
with their origin coordinates; accordingly,
as shown at the top of Figure ??,
you have inserted
a let tile introducing variables \texttt{x} and \texttt{y}
in the function body.
Your remaining task is to restructure your code so that \texttt{x}
and \texttt{y} are bound to the origin coordinates
\texttt{( n * n / 9 , n )} currently in the body of the let term.
You begin by selecting the \texttt{in} delimiter,
which disassembles the \texttt{let}-tile into a pair of \emph{shards}.
You then pick up the \texttt{in} shard into your backpack,
move right once, and put it down,
upon which \tylr~ reassembles the \texttt{let}-tile
and returns you to pointing mode.

% Your editing workflow was similar to what you might
% have done in a text editor---delete the \texttt{in}
% delimiter, move right, re-type---except that \tylr~
% skipped all cursor positions within the parentheses tile
% when you moved right.
Notice that you skipped all cursor positions within
the parentheses tile when you moved right.
The \texttt{in} shard in your backpack cannot be assembled into
a whole tile on its own, meaning at least one matching shard---in
this case, \texttt{let x , y =}---is
anchored within the current tile sequence.
This restricts your movement of the \texttt{in}
shard to cursor positions of the same sequence,
as placing it in any other position would
violate proper tile nesting on reassembly.
\note{say something explicitly of the form "when your backpack
is hungry... blah blah"}


\note{add back some discussion comparing to text editing
and other structure editors;
similarity with text workflow,
while making it more efficient + less cognitive load;
other structure editors would force you to translate
edits into term-based selections, can be awkward or
not the most efficient in terms of selection size}

We call your backpack full or hungry as a way
to narrativize its control of your movement.
When your backpack is full, it is ``satisfied''
and lets you move freely and leisurely through
your code.
When your backpack is hungry, it accelerates your
movement through your code in its ``impatience''
to end its hunger, which can happen in one of two ways.
Either you can empty your backpack, like in the last example,
freeing it of all earthly possessions
and desires; or you may ``feed'' it.

% We hypothesize that such a restriction would lead to both greater
% editing efficiency and reduced cognitive load compared to
% text editing on similar tasks.

% We hypothesize that such a restriction would easy to learn
% given
% \begin{itemize}
% \item be easy to learn, given the workflow similarity to text editing;
% \item lead to greater editing efficiency than text editing due to
%     the fewer keypresses needed to reach valid paste/restructure targets; and
% \item reduce cognitive load compared to text editing because you
%     no longer need to count delimiters to ensure you have reached
%     a valid paste/restructure target.
% \end{itemize}

\paragraph{Feeding your hungry backpack}
Say you have filled the hole in Figure ?? with
the variables \texttt{x} and \texttt{y} you defined
in the previous example, as shown in Figure ??.
Upon reviewing the term structure, however, you
discover that pairs are right-associative in \tylr,
so you need to wrap \texttt{x , y} in parentheses
in order to satisfy the expected return type.
You also notice that the parentheses in the definition
of the \texttt{let} tile are now redundant
and decide to ``recycle'' them.
You move your cursor to the right parenthesis,
select it, and pick it up into your backpack.
At this point your backpack is hungry and restricts
your movement to the tile sequence within the
let definition.
You could end its hunger by putting down
the right parenthesis somewhere within that sequence
or, alternatively, by moving over to the
left parenthesis and picking it up as well (Figure ??).

% When your backpack carries multiple selections,
% it dictates the order in which you can put them down.
% Most of the time it behaves like a stack, putting
% down first the last picked up selection; we discuss
% deviations

Now your backpack is full, as it carries both shards
needed to assemble a whole parenthesis tile,
and you may move freely again.
You carry the parentheses over to the body of the
let term and wrap \texttt{x , y} to complete your
restructuring.

The last example showed how \tylr~ lets you carry \emph{multiple}
related range selections in your backpack.
This ability vastly improves your selecting precision
compared to prior designs.
From the perspective of the term syntax,
where other structure editors force you to select
complete subtrees, \tylr~ lets you select individual
\emph{nodes} in the tree and splice them back in
elsewhere.

\paragraph{Staging tile insertion and removal}
\note{possibly add some connecting intro here}
Say you have completed an initial draft of your goal program,
where each circle's radius is the sum of its origin
coordinates, as shown in Figure ??.
You discover, however, that the circles are so large that
they fill your viewport, so you would like to make them smaller.
You begin by inserting a left parenthesis
before \texttt{x + y}, your intention being to wrap
the sum and divide it by a constant factor.
Upon this insertion, \tylr~ automatically enters
restructuring mode with the matching right parenthesis
in your backpack.
You move right, put down the right parenthesis,
and complete your desired transformation.


\paragraph{Picky eating}
Your backpack is a ``picky eater'' in the sense that
it will refuse to carry any selections with caps of
different sort.

\note{show small inline example of selecting
selection with caps of different sort}

\note{show small inline example of selection
with pattern caps cutting across expressions}

\subsection{Removing tiles}



% \subsection{\note{everything below this is old overview}}

% Tile-based structure editing departs from traditional
% structure editors in avoiding direct user modifications
% to the AST.
% Instead, much like with a text editor, the user modifies a separate
% ``flattened'' editing structure that affords more flexible
% editing mechanisms, which is subsequently parsed into the
% abstract syntax.
% Unlike a text editor, however, a tile-based editor ensures
% that every edit state can be parsed successfully.

% In this section we motivate and give an example-driven
% overview of tile-based editing as implemented
% in \tylr. We begin by describing the limitations of
% traditional structure editors, then show how tile-based
% editing overcomes these limitations.

% \subsection{A typical structure editor} \label{sec:simple-editor}

% Structure editors, also known as projectional editors, typically
% follow a projectional architecture: the editor projects an
% abstract syntax tree into a concrete representation,
% and user interactions with the representation are interpreted
% by the editor as direct modifications to the AST.

% For example, suppose we wish to edit expressions with the abstract
% syntax presented in Figure \ref{fig:tile-syntax}.
% A simple editor might project the current expression
% to a textual notation decorated with nested boxes, such
% that there is a one-to-one correspondence between
% boxes and terms. \note{example}
% In this editor, the cursor selects a subterm of the
% current program expression and may be moved through
% the current expression via a pre-order traversal.
% Edits are context-free transformations
% of the selected subterm:
%   deletion replaces the current subterm with
%     a hole of the same sort; and
%   construction replaces the current subterm
%     with the new form, making the original subterm
%     a child of the new form if possible, and moving
%     the cursor to the next child position if available.

% While simple, this editor is representative of existing structure
% editors in the way that it restricts editing affordances to easily
% understood tree manipulations of the abstract syntax.
% We believe such restrictions unacceptably hamper usability.
% Consider the following classes of edits that we may wish to
% perform---and could perform in a text editor---but cannot with the
% given interface:

% \paragraph{Linearly constructing operator sequences}
% In a text editor, we may type the characters \texttt{2}, \texttt{*},
% \texttt{3}, \texttt{+}, \texttt{4}
% to construct the expression \texttt{2 * 3 + 4} with
% the usual precedence-based operator associations.
% In our simple structure editor, the same inputs would construct
% the following series of edit states: \note{todo figure}.
% To get the associations we want, we would need to interleave
% our constructions with movements through the expression tree
% to ensure that the correct child is chosen before constructing
% the plus node: \note{todo figure}.
% This particular limitation of structure editing is well-recognized
% in prior work, which we discuss in greater detail in Section
% \ref{sec:related-work}.

% \paragraph{Preserving children of deleted terms}
% Deletion in our simple editor is quite coarse, deleting whole
% trees rather than individual nodes.


% \begin{itemize}
% \item
%   we now describe a few classes of edits that we may wish to perform---and
%   could perform in a text editor---but cannot with the given structured
%   interface
% \item structure-oblivious linear construction of operator sequences
%   \begin{itemize}
%     \item eg going from \texttt{2 * 3 + 4} as opposed to \texttt{2 * (3 + 4)}
%     \item this particular limitation of naive structure editing has received
%       the most attention in prior work
%     \begin{itemize}
%       \item some structure editors defer to text at the leaves
%       \item others develop more sophisticated methods, e.g.,
%         modeless structure editing article,
%         MPS's side transforms
%     \end{itemize}
%   \end{itemize}
% \item deleting the root of a term,
%   leaving behind its children for further processing
%   (eg splicing into the surrounding context)
%   \begin{itemize}
%     \item eg it is not possible to delete a let expression and leave behind its body
%     \item eg it is not possible to remove a conditional expression
%       and leave behind a branch to take its place, or to subsequently join the
%       two remaining branches with an operator
%     \item note how there's no room in the strict tree structure to deal with
%       multiple "floating" children
%     \item MPS mitigates this by leaving behind its first child if its the
%       same sort, but already this does not satisfy the use case described above,
%       and in general the user should have the freedom to choose
%   \end{itemize}
% \item selecting and restructuring sub- and cross-structural
%   parts of the program
%   \begin{itemize}
%     \item eg it is not possible to select \texttt{3 + 4} in \texttt{2 * 3 + 4}
%       and re-associate the expression, as one might in a text editor by
%       wrapping the selection in parentheses
%     \item eg it is not possible to select \texttt{let x = \_ in} and
%       move it before \texttt{let y = 2 in}
%     \item eg it is not possible to select \texttt{in} of \texttt{let x = \_ in}
%       and move it to wrap the subsequent portion of the expression
%     \begin{itemize}
%       \item as one might in a text editor by deleting \texttt{in},
%         moving the caret, re-typing it elsewhere
%       \item as one might when constructing the let line for the first time:
%         having typed out \texttt{let x =}, it remains to move the caret over
%         and type the \texttt{in}
%     \end{itemize}
%     \item while some of these examples are contrived given the simplicity of
%       the language, such selections and edits occur frequently in practice
%     \begin{itemize}
%       \item eg 6\% of logged edits in Design Requirements
%         paper involve making
%         selections across structural boundaries, 10\% of edits excluding those
%         that only involve name changes rather than structural changes
%     \end{itemize}
%   \end{itemize}
% \end{itemize}

% \subsection{\tylr: a tile-based editor}

% We now describe the design of \tylr, a tile-based structure
% editor.
% Given the disadvantages of operating directly on abstract syntax
% trees, \tylr~ presents programs to the user in a separate
% concrete syntax equipped with its own syntax-directed editing
% mechanisms.
% The concrete syntax is a ``flattened'' version of the abstract
% syntax, where the structural units correspond not to semantic
% terms of the language but rather syntactic groups of matching
% delimiters and their bidelimited children.
% We call these structural units \emph{tiles}.
% Figure \ref{fig:tile-syntax} shows the subset of \tylr's
% concrete syntax corresponding to the abstract syntax in
% Figure \ref{fig:language-syntax}.

% Unlike terms of the abstract syntax, tiles can be arranged
% sequentially.
% The cursor resides between consecutive pairs of
% tiles (or between a tile and its parent container),
% much as a text cursor resides between characters.
% Figure \note{todo} shows the different cursor positions
% in the operator sequence \texttt{2 * 3 + 4}.

% \subsubsection{Linear construction of operator sequences}
% Figure \note{todo} shows the construction of the operator
% sequence \texttt{2 * 3 + 4}. Unlike with the simple editor described
% in Section \ref{sec:simple-editor}, it is not necessary

% Unlike terms in the abstract syntax, tiles may be arranged
% sequentially as well as hierarchically.

% Rather than manipulating structures of the language syntax,
% a tile-based structure editor works within a parallel editor syntax.
% The central form in the editor syntax is the unassociated operator
% sequence. Operator sequence elements each take one of four shapes---operand,
% unary prefix, unary postfix, and
% binary infix---which we collectively refer to as \emph{tiles}.
% Tiles may in turn contain nested operator sequences.

% Like text, the editor syntax provides a flattened, more linear representation
% of the language syntax.
% Unlike text, the editor syntax maintains hierarchies of
% bidelimited children and can always be parsed into the
% language syntax, provided that the structure first undergoes
% a hole fixing pass in which holes are inserted and removed
% as needed.

% \note{talk about automatic hole fixing + operand vs operator holes}

% \note{after describing, note bonus edits that combine limitations from previous selection}

% \note{do get into how restructuring mode fits naturally within the deletion vs construction}